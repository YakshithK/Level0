{"chunk": "// Game Config\nvar config = {\n    type: Phaser.AUTO,\n    parent: 'phaser-example',\n    width: 800,\n    height: 600,\n    scene: MyScene\n}"}
{"chunk": "// Sprite Logic\nfunction () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MyScene = /** @class */ (function (_super) {\n    __extends(MyS"}
{"chunk": "// Scene Class\nclass MyScene extends Phaser.Scene {\n\n    public preload ()\n    {\n        this.load.atlas('cards', 'assets/atlas/cards.png', 'assets/atlas/cards.json');\n    }\n\n    public create ()\n    {\n        let sprite = this.add.sprite(400, 300, 'cards', 'clubs3');\n\n        sprite.setInteractive();\n\n        this.input.on('pointerdown', function () {\n\n            sprite.setFrame('hearts4');\n\n        });\n    }\n\n}"}
{"chunk": "// Preload Method\npreload ()\n    {\n        this.load.atlas('cards', 'assets/atlas/cards.png', 'assets/atlas/cards.json');\n    }"}
{"chunk": "// Create Method\ncreate ()\n    {\n        let sprite = this.add.sprite(400, 300, 'cards', 'clubs3');\n\n        sprite.setInteractive();\n\n        this.input.on('pointerdown', function () {\n\n            sprite.setFrame('hearts4');\n\n        }"}
{"chunk": "// Game Config\nlet config = {\n    type: Phaser.AUTO,\n    parent: 'phaser-example',\n    width: 800,\n    height: 600,\n    scene: MyScene\n}"}
{"chunk": "// Sprite Logic\nclass MyScene extends Phaser.Scene {\n\n    public preload ()\n    {\n        this.load.atlas('cards', 'assets/atlas/cards.png', 'assets/atlas/cards.json');\n    }\n\n    public create ()\n    {\n        let sprite = this.add.sprite(400, 300, 'cards', 'clubs3');\n\n        sprite.setInteractive();\n\n        this.input.on('pointerdown', function () {\n\n            sprite.setFrame('hearts4');\n\n        }"}
{"chunk": "/**\n * @typedef {object} Phaser.Types.Core.GameConfig\n * @since 3.0.0\n *\n * @property {(number|string)} [width=1024] - The width of the game, in game pixels.\n * @property {(number|string)} [height=768] - The height of the game, in game pixels.\n * @property {number} [zoom=1] - Simple scale applied to the game canvas. 2 is double size, 0.5 is half size, etc.\n * @property {number} [type=CONST.AUTO] - Which renderer to use. Phaser.AUTO, Phaser.CANVAS, Phaser.HEADLESS, or Phaser.WEBGL. AUTO picks WEBGL if available, otherwise CANVAS."}
{"chunk": "* @property {string} [canvasStyle=null] - CSS styles to apply to the game canvas instead of Phasers default styles.\n * @property {boolean}[customEnvironment=false] - Is Phaser running under a custom (non-native web) environment? If so, set this to `true` to skip internal Feature detection. If `true` the `renderType` cannot be left as `AUTO`.\n * @property {CanvasRenderingContext2D} [context] - Provide your own Canvas Context for Phaser to use, instead of creating one.\n * @property {(Phaser.Types.Scenes.SceneType|Phaser.Types.Scenes.SceneType[])} [scene=null] - A scene or scenes to add to the game. If several are given, the first is started; the remainder are started only if they have `{ active: true }`. See the `sceneConfig` argument in `Phaser.Scenes.SceneManager#add`."}
{"chunk": "* @property {string[]} [seed] - Seed for the random number generator.\n * @property {string} [title=''] - The title of the game. Shown in the browser console.\n * @property {string} [url='https://phaser.io'] - The URL of the game. Shown in the browser console.\n * @property {string} [version=''] - The version of the game. Shown in the browser console.\n * @property {boolean} [autoFocus=true] - Automatically call window.focus() when the game boots. Usually necessary to capture input events if the game is in a separate frame.\n * @property {(boolean|Phaser.Types.Core.InputConfig)} [input] - Input configuration, or `false` to disable all game input."}
{"chunk": "* @property {boolean} [disableContextMenu=false] - Disable the browser's default 'contextmenu' event (usually triggered by a right-button mouse click).\n * @property {(boolean|Phaser.Types.Core.BannerConfig)} [banner=false] - Configuration for the banner printed in the browser console when the game starts.\n * @property {Phaser.Types.Core.DOMContainerConfig} [dom] - The DOM Container configuration object.\n * @property {Phaser.Types.Core.FPSConfig} [fps] - Game loop configuration.\n * @property {Phaser.Types.Core.RenderConfig} [render] - Game renderer configuration.\n * @property {Phaser.Types.Core.CallbacksConfig} [callbacks] - Optional callbacks to run before or after game boot.\n * @property {Phaser.Types.Core.LoaderConfig} [loader] - Loader configuration."}
{"chunk": "* @property {Phaser.Types.Core.ImagesConfig} [images] - Images configuration.\n * @property {Phaser.Types.Core.PhysicsConfig} [physics] - Physics configuration.\n * @property {Phaser.Types.Core.PluginObject|Phaser.Types.Core.PluginObjectItem[]} [plugins] - Plugins to install.\n * @property {Phaser.Types.Core.ScaleConfig} [scale] - The Scale Manager configuration.\n * @property {Phaser.Types.Core.AudioConfig} [audio] - The Audio Configuration object.\n * @property {Phaser.Types.Core.PipelineConfig} [pipeline] - The WebGL Pipeline configuration object. Can also be part of the `RenderConfig`.\n * @property {(string|number)} [backgroundColor=0x000000] - The background color of the game canvas. The default is black."}
{"chunk": "* @property {Phaser.Scale.ScaleModeType} [mode=Phaser.Scale.ScaleModes.NONE] - The scale mode.\n * @property {WidthHeight} [min] - The minimum width and height the canvas can be scaled down to.\n * @property {WidthHeight} [max] - The maximum width the canvas can be scaled up to.\n * @property {boolean} [autoRound=false] - Automatically round the display and style sizes of the canvas. This can help with performance in lower-powered devices.\n * @property {Phaser.Scale.CenterType} [autoCenter=Phaser.Scale.Center.NO_CENTER] - Automatically center the canvas within the parent?\n * @property {number} [resizeInterval=500] - How many ms should elapse before checking if the browser size has changed?"}
{"chunk": "/**\n * @callback Phaser.Types.GameObjects.Group.GroupClassTypeConstructor\n * @since 3.0.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */"}
{"chunk": "/**\n * @typedef {object} Phaser.Types.Scenes.CreateSceneFromObjectConfig\n * @since 3.17.0\n *\n * @property {Phaser.Types.Scenes.SceneInitCallback} [init] - The scene's init callback.\n * @property {Phaser.Types.Scenes.ScenePreloadCallback} [preload] - The scene's preload callback.\n * @property {Phaser.Types.Scenes.SceneCreateCallback} [create] - The scene's create callback.\n * @property {Phaser.Types.Scenes.SceneUpdateCallback} [update] - The scene's update callback. See {@link Phaser.Scene#update}.\n * @property {any} [extend] - Any additional properties, which will be copied to the Scene after it's created (except `data` or `sys`).\n * @property {any} [extend.data] - Any values, which will be merged into the Scene's Data Manager store.\n */"}
{"chunk": "/**\n * Can be defined on your own Scenes. Use it to create your game objects.\n * This method is called by the Scene Manager when the scene starts, after `init()` and `preload()`.\n * If the LoaderPlugin started after `preload()`, then this method is called only after loading is complete.\n *\n * @callback Phaser.Types.Scenes.SceneCreateCallback\n * @since 3.0.0\n *\n * @this Phaser.Scene\n * @param {object} data - Any data passed via `ScenePlugin.add()` or `ScenePlugin.start()`. Same as Scene.settings.data.\n */"}
{"chunk": "/**\n * Can be defined on your own Scenes.\n * This method is called by the Scene Manager when the scene starts, before `preload()` and `create()`.\n *\n * @callback Phaser.Types.Scenes.SceneInitCallback\n * @since 3.0.0\n *\n * @this Phaser.Scene\n * @param {object} data - Any data passed via `ScenePlugin.add()` or `ScenePlugin.start()`. Same as Scene.settings.data.\n */"}
{"chunk": "/**\n * Can be defined on your own Scenes. Use it to load assets.\n * This method is called by the Scene Manager, after `init()` and before `create()`, only if the Scene has a LoaderPlugin.\n * After this method completes, if the LoaderPlugin's queue isn't empty, the LoaderPlugin will start automatically.\n *\n * @callback Phaser.Types.Scenes.ScenePreloadCallback\n * @since 3.0.0\n *\n * @this Phaser.Scene\n */"}
{"chunk": "/**\n * @callback Phaser.Types.Scenes.SceneTransitionOnStartCallback\n * @since 3.60.0\n *\n * @this Phaser.Scene\n * @param {Phaser.Scene} fromScene - Scene instance to transition from.\n * @param {Phaser.Scene} toScene - Scene instance to transition to.\n * @property {number} [duration=1000] - The duration, in ms, for the transition to last.\n */"}
{"chunk": "/**\n * @typedef {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig|function)} Phaser.Types.Scenes.SceneType\n * @since 3.60.0\n */"}
{"chunk": "/**\n * @callback Phaser.Types.Scenes.SceneUpdateCallback\n * @since 3.0.0\n *\n * @this Phaser.Scene\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\n */"}
{"chunk": "/**\n * @typedef {object} Phaser.Types.Scenes.SettingsObject\n * @since 3.0.0\n *\n * @property {number} status - The current status of the Scene. Maps to the Scene constants.\n * @property {string} key - The unique key of this Scene. Unique within the entire Game instance.\n * @property {boolean} active - The active state of this Scene. An active Scene updates each step.\n * @property {boolean} visible - The visible state of this Scene. A visible Scene renders each step.\n * @property {boolean} isBooted - Has the Scene finished booting?\n * @property {boolean} isTransition - Is the Scene in a state of transition?\n * @property {?Phaser.Scene} transitionFrom - The Scene this Scene is transitioning from, if set.\n * @property {number} transitionDuration - The duration of the transition, if set."}
{"chunk": "* @property {boolean} transitionAllowInput - Is this Scene allowed to receive input during transitions?\n * @property {object} data - a data bundle passed to this Scene from the Scene Manager.\n * @property {(false|Phaser.Types.Loader.FileTypes.PackFileSection)} pack - Files to be loaded before the Scene begins.\n * @property {?(Phaser.Types.Cameras.Scene2D.CameraConfig|Phaser.Types.Cameras.Scene2D.CameraConfig[])} cameras - The Camera configuration object.\n * @property {Object.<string, string>} map - The Scene's Injection Map.\n * @property {Phaser.Types.Core.PhysicsConfig} physics - The physics configuration object for the Scene.\n * @property {Phaser.Types.Core.LoaderConfig} loader - The loader configuration object for the Scene."}
{"chunk": "/**\n * @typedef {object} Phaser.Types.Tilemaps.CreateFromObjectLayerConfig\n * @since 3.50.0\n *\n * @property {number} [id] - A unique Object ID to convert.\n * @property {number} [gid] - An Object GID to convert.\n * @property {string} [name] - An Object Name to convert.\n * @property {string} [type] - An Object Type to convert.\n * @property {function} [classType] - A custom class type to convert the objects in to. The default is {@link Phaser.GameObjects.Sprite}. A custom class should resemble Sprite or Image; see {@link Phaser.Types.Tilemaps.CreateFromObjectsClassTypeConstructor}."}
{"chunk": "* @property {boolean} [ignoreTileset] - By default, gid-based objects copy properties and respect the type of the tile at that gid and treat the object as an override. If this is true, they don't, and use only the fields set on the object itself.\n * @property {Phaser.Scene} [scene] - A Scene reference, passed to the Game Objects constructors.\n * @property {Phaser.GameObjects.Container} [container] - Optional Container to which the Game Objects are added.\n * @property {(string|Phaser.Textures.Texture)} [key] - Optional key of a Texture to be used, as stored in the Texture Manager, or a Texture instance. If omitted, the object's gid's tileset key is used if available."}
{"chunk": "/**\n * @callback Phaser.Types.Tilemaps.CreateFromObjectsClassTypeConstructor\n * @since 3.60.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\n */"}
{"chunk": "declare class SpineContainer extends Phaser.GameObjects.Container implements Phaser.GameObjects.Components.AlphaSingle, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Mask, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {\n    constructor(scene: Phaser.Scene, pluginManager: SpinePlugin, x?: number, y?: number, children?: SpineGameObject[]);\n\n    list: SpineGameObject[];\n\n    exclusive: boolean;\n\n    maxSize: number;\n    position: number;\n\n    localTransform: Phaser.GameObjects.Components.TransformMatrix;\n\n    scrollFactorX: number;\n    scrollFactorY: number;\n\n    readonly originX: number;\n    readonly originY: number;\n    readonly displayOriginX: number;"}
{"chunk": "readonly displayOriginY: number;\n\n    setExclusive(value?: boolean): this;\n    getBounds(output?: Phaser.Geom.Rectangle): Phaser.Geom.Rectangle;\n    pointToContainer(source: object | Phaser.Geom.Point | Phaser.Math.Vector2, output?: object | Phaser.Geom.Point | Phaser.Math.Vector2): object | Phaser.Geom.Point | Phaser.Math.Vector2;\n    getBoundsTransformMatrix(): Phaser.GameObjects.Components.TransformMatrix;\n    add(child: SpineGameObject | SpineGameObject[]): this;\n    addAt(child: SpineGameObject | SpineGameObject[], index?: number): this;\n    getAt(index: number): SpineGameObject;\n    getIndex(child: SpineGameObject): number;\n    sort(property: string, handler?: Function): this;\n    getByName(name: string): SpineGameObject;"}
{"chunk": "readonly next: SpineGameObject;\n    readonly previous: SpineGameObject;\n\n    protected preDestroy(): void;\n\n    clearAlpha(): this;\n    setAlpha(value?: number): this;\n\n    alpha: number;\n    blendMode: Phaser.BlendModes | string;\n\n    setBlendMode(value: string | Phaser.BlendModes): this;\n\n    width: number;\n    height: number;\n\n    displayWidth: number;\n    displayHeight: number;\n\n    setSize(width: number, height: number): this;\n    setDisplaySize(width: number, height: number): this;\n\n    depth: number;\n\n    setDepth(value: number): this;\n\n    mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask;\n\n    setMask(mask: Phaser.Display.Masks.BitmapMask | Phaser.Display.Masks.GeometryMask): this;\n    clearMask(destroyMask?: boolean): this;"}
{"chunk": "createBitmapMask(renderable?: Phaser.GameObjects.GameObject): Phaser.Display.Masks.BitmapMask;\n    createGeometryMask(graphics?: Phaser.GameObjects.Graphics): Phaser.Display.Masks.GeometryMask;\n\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n\n    scale: number;\n    scaleX: number;\n    scaleY: number;\n\n    angle: number;\n    rotation: number;\n\n    setPosition(x?: number, y?: number, z?: number, w?: number): this;\n    setRandomPosition(x?: number, y?: number, width?: number, height?: number): this;\n    setRotation(radians?: number): this;\n    setAngle(degrees?: number): this;\n    setScale(x: number, y?: number): this;\n    setX(value?: number): this;\n    setY(value?: number): this;\n    setZ(value?: number): this;\n    setW(value?: number): this;"}
{"chunk": "getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;\n    getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;\n\n    getParentRotation(): number;\n\n    visible: boolean;\n\n    setVisible(value: boolean): this;\n}\n\ndeclare interface SpineContainerConfig extends Phaser.Types.GameObjects.GameObjectConfig {\n    x?: number;\n    y?: number;\n    children?: SpineGameObject | SpineGameObject[];\n}"}
{"chunk": "declare class SpineGameObject extends Phaser.GameObjects.GameObject implements Omit<Phaser.GameObjects.Components.ComputedSize, 'setSize'>, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {\n    constructor(scene: Phaser.Scene, pluginManager: SpinePlugin, x: number, y: number, key?: string, animationName?: string, loop?: boolean);\n\n    alpha: number;\n    angle: number;\n\n    readonly blendMode: number;\n\n    blue: number;\n    bounds: any;\n    displayOriginX: number;\n    displayOriginY: number;\n    drawDebug: boolean;\n    depth: number;\n    displayWidth: number;\n    displayHeight: number;\n    flipX: boolean;\n    flipY: boolean;\n    green: number;"}
{"chunk": "findTransformConstraint(constraintName: string): spine.TransformConstraintData;\n    getAnimationList(): string[];\n    getAttachment(slotIndex: number, attachmentName: string): spine.Attachment;\n    getAttachmentByName(slotName: string, attachmentName: string): spine.Attachment;\n    getBoneList(): string[];\n    getBounds(): any;\n    getCurrentAnimation(trackIndex?: number): spine.Animation;\n    getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;\n    getParentRotation(): number;\n    getRootBone(): spine.Bone;\n    getSkinList(): string[];\n    getSlotList(): string[];"}
{"chunk": "getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix, parentMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;\n    play(animationName: string, loop?: boolean, ignoreIfPlaying?: boolean): SpineGameObject;\n\n    protected preUpdate(time: number, delta: number): void;\n    protected preDestroy(): void;\n\n    refresh(): SpineGameObject;\n    resetFlip(): this;\n    setAlpha(value?: number): SpineGameObject;\n    setAngle(degrees?: number): this;\n    setAnimation(trackIndex: number, animationName: string, loop?: boolean, ignoreIfPlaying?: boolean): spine.TrackEntry;\n    setAttachment(slotName: string, attachmentName: string): SpineGameObject;\n    setBonesToSetupPose(): SpineGameObject;"}
{"chunk": "willRender(): boolean;\n}\n\ndeclare interface SpineGameObjectConfig extends Phaser.Types.GameObjects.GameObjectConfig {\n    key?: string;\n    animationName?: string;\n    loop?: boolean;\n    skinName?: string;\n    slotName?: string;\n    attachmentName?: string;\n}"}
{"chunk": "declare namespace Phaser.Loader {\n    interface LoaderPlugin extends Phaser.Events.EventEmitter {\n        spine(key: string | Phaser.Loader.FileTypes.SpineFileConfig | Phaser.Loader.FileTypes.SpineFileConfig[], jsonURL: string, atlasURL: string | string[], preMultipliedAlpha?: boolean, textureXhrSettings?: Phaser.Types.Loader.XHRSettingsObject, atlasXhrSettings?: Phaser.Types.Loader.XHRSettingsObject): LoaderPlugin;\n    }\n}\n\ndeclare namespace Phaser.GameObjects {\n    interface GameObjectFactory {\n        spine(x: number, y: number, key?: string, animationName?: string, loop?: boolean): SpineGameObject;\n        spineContainer(x: number, y: number, children?: SpineGameObject | SpineGameObject[]): SpineContainer;\n    }\n\n\tinterface GameObjectCreator {"}
{"chunk": "spine(config: SpineGameObjectConfig, addToScene?: boolean): SpineGameObject;\n        spineContainer(config: SpineContainerConfig, addToScene?: boolean): SpineContainer;\n    }\n}\n\ndeclare class SpinePlugin extends Phaser.Plugins.ScenePlugin {\n    constructor(scene: Phaser.Scene, pluginManager: Phaser.Plugins.PluginManager);\n\n    readonly isWebGL: boolean;\n\n    cache: Phaser.Cache.BaseCache;\n    spineTextures: Phaser.Cache.BaseCache;\n    json: Phaser.Cache.BaseCache;\n    textures: Phaser.Textures.TextureManager;\n    drawDebug: boolean;\n    gl: WebGLRenderingContext;\n    renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer;\n    sceneRenderer: spine.webgl.SceneRenderer;\n    skeletonRenderer: spine.canvas.SkeletonRenderer | spine.webgl.SkeletonRenderer;"}
{"chunk": "// Scene Class\nclass world extends Phaser.Scene {\n  constructor () {\n    super({ key: 'world' });\n  }\n  \n\n  preload () {\n    this.sys.game.world = this;\n\n    // load binary game assets from original SC2K\n    this.load.binary(CONST.PAL_MSTR_BMP, CONST.ASSETS_PATH + CONST.FILE_PAL_MSTR_BMP);\n    this.load.binary(CONST.LARGE_DAT,    CONST.ASSETS_PATH + CONST.FILE_LARGE_DAT);\n\n    // start import once files are loaded\n    this.load.once(CONST.E_LOAD_COMPLETE, () => {\n      this.palette = new palette({ scene: this });\n      this.artwork = new artwork({ scene: this });\n      this.tiles = this.artwork.tiles;\n\n      // initialize city\n      this.city = new city({ scene: this });\n    });\n  }\n  \n\n  create () {\n    // load default city\n    this.city.load.loadDefaultCity().then(() => {\n      this.star"}
{"chunk": "// Preload Method\npreload () {\n    this.sys.game.world = this;\n\n    // load binary game assets from original SC2K\n    this.load.binary(CONST.PAL_MSTR_BMP, CONST.ASSETS_PATH + CONST.FILE_PAL_MSTR_BMP);\n    this.load.binary(CONST.LARGE_DAT,    CONST.ASSETS_PATH + CONST.FILE_LARGE_DAT);\n\n    // start import once files are loaded\n    this.load.once(CONST.E_LOAD_COMPLETE, () => {\n      this.palette = new palette({ scene: this });\n      this.artwork = new artwork({ scene: this });\n      this.tiles = this.artwork.tiles;\n\n      // initialize city\n      this.city = new city({ scene: this });\n    }"}
{"chunk": "// Create Method\ncreate () {\n    // load default city\n    this.city.load.loadDefaultCity().then(() => {\n      this.start();\n    }"}
{"chunk": "// Scene Class\nclass ui extends Phaser.Scene {\n  constructor () {\n    super({\n      key: 'ui',\n      active: true\n    });\n\n    this.debug = false;\n    this.debugOffset = -250;\n    this.boundsBuffer = 300;\n    \n    this.viewport = {\n      displayBounds: {},\n      displayBoundsBuffer: {},\n      worldBounds: {},\n      worldBoundsBuffer: {}\n    };\n\n    this.preloadComplete = false;\n    this.initialized = false;\n  }\n\n  preload () {\n    this.common = this.sys.game.common;\n    this.preloadComplete = true;\n  }\n\n  create () {\n    if (!this.preloadComplete)\n      return;\n\n    this.common.ui = this;\n    this.initialized = true;\n  }\n\n\n  updateBounds () {\n    if (!this.common || !this.common.world || !this.common.world.worldCamera)\n      return;\n\n    let camera = this.common.world.worldCamera.camera;\n\n"}
{"chunk": "// Create Method\ncreate () {\n    if (!this.preloadComplete)\n      return;\n\n    this.common.ui = this;\n    this.initialized = true;\n  }"}
{"chunk": "// Update Method\nupdate (time, delta) {\n  //   this.updateBounds();\n  // }\n\n  resize () {\n    this.cameras.main.setViewport(0, 0, document.documentElement.clientWidth, document.documentElement.clientHeight);\n\n    if (this.displayArea && this.displayAreaBuffer && this.debug) {\n      this.displayArea.clear();\n      this.displayAreaBuffer.clear();\n\n      this.displayArea = undefined;\n      this.displayAreaBuffer = undefined;\n    }"}
{"chunk": "// Sprite Logic\nfunction() {\n    var gameConfig = {\n       type: Phaser.CANVAS,\n       width: gameOptions.tileSize * 4 + gameOptions.tileSpacing * 5,\n       height: (gameOptions.tileSize * 4 + gameOptions.tileSpacing * 5) * 16 / 9,\n       backgroundColor: 0xecf0f1,\n       scene: [preloadAssets, playGame]\n   };\n    game = new Phaser.Game(gameConfig);\n    window.focus();//获得窗口焦点\n    resize();//调整窗口\n    window.addEventListener(\"resize\", resize, false);\n}\n\nvar preloadAssets = new Phaser.Class({\n    Extends: Phaser.Scene,\n    initialize:\n    function preloadAssets(){\n        Phaser.Scene.call(this, {key: \"PreloadAssets\"});\n    },\n     // 预加载 各种资源\n    preload: function(){\n        this.load.image(\"spot\", \"assets/sprites/spot.png\");\n        this.load.image(\"gametitle\", \"assets/sprites/gametitle.pn"}
{"chunk": "// Sprite Logic\nfunction(){\n        this.scene.start(\"PlayGame\");\n    }\n})\n\nvar playGame = new Phaser.Class({\n    Extends: Phaser.Scene,\n    initialize:\n    function playGame(){\n        Phaser.Scene.call(this, {key: \"PlayGame\"});\n    },\n     // 游戏开始运行\n    create: function(){\n        this.fieldArray = [];\n        this.fieldGroup = this.add.group();\n        this.score = 0;//4096 增加得分\n        this.bestScore = localStorage.getItem(gameOptions.localStorageName) == null ? 0 : localStorage.getItem(gameOptions.localStorageName);\n        for(var i = 0; i < 4; i++){\n            this.fieldArray[i] = [];\n            for(var j = 0; j < 4; j++){\n                var spot = this.add.sprite(this.tileDestination(j, COL), this.tileDestination(i, ROW), \"spot\")\n                var tile = this.add.sprite(this.t"}
{"chunk": "// Sprite Logic\nfunction(){\n            this.scene.start(\"PlayGame\");\n        }, this)\n        this.add.sprite(this.tileDestination(1, COL), this.tileDestination(0, ROW) - 200, \"scorepanel\");\n        this.add.sprite(this.tileDestination(1, COL), this.tileDestination(0, ROW) - 270, \"scorelabels\");\n        this.add.sprite(10, 5, \"gametitle\").setOrigin(0, 0);\n        var howTo = this.add.sprite(game.config.width, 5, \"howtoplay\");\n        howTo.setOrigin(1, 0);\n        var logo = this.add.sprite(game.config.width / 2, game.config.height, \"logo\");\n        logo.setOrigin(0.5, 1);\n        logo.setInteractive();\n        logo.on(\"pointerdown\", function(){\n            window.location.href = \"http://www.nbdp.net/\"\n        }"}
{"chunk": "// Sprite Logic\nfunction(e){\n        var swipeTime = e.upTime - e.downTime;\n        var swipe = new Phaser.Geom.Point(e.upX - e.downX, e.upY - e.downY);\n        var swipeMagnitude = Phaser.Geom.Point.GetMagnitude(swipe);\n        var swipeNormal = new Phaser.Geom.Point(swipe.x / swipeMagnitude, swipe.y / swipeMagnitude);\n        if(swipeMagnitude > 20 && swipeTime < 1000 && (Math.abs(swipeNormal.y) > 0.8 || Math.abs(swipeNormal.x) > 0.8)){\n            var children = this.fieldGroup.getChildren();\n            if(swipeNormal.x > 0.8) {\n                for (var i = 0; i < children.length; i++){\n                    children[i].depth = game.config.width - children[i].x;\n                }\n                this.handleMove(0, 1);\n            }\n            if(swipeNormal.x < -0.8) {\n                f"}
{"chunk": "// Scene Class\nclass playGame extends Phaser.Scene{\n\n\tconstructor(){\n\t\tsuper(\"playGame\");\n\t}\n\t// 预加载\n\tpreload(){\n\n\t\t// 加载各种资源\n\t\tthis.load.image(\"target\",\"assets/target.png\");\n\t\tthis.load.image(\"knife\",\"assets/knife.png\");\n\n\t}\n\t// 游戏开始运行\n\tcreate(){\n\t\t //v1.2 在游戏一开始设置转动的速度与一致，即默认值\n        this.currentRotationSpeed = gameOptions.rotationSpeed;\n        this.newRotationSpeed = gameOptions.rotationSpeed;\n\n\t\t// 在游戏开始时设置可以扔刀\n\t\tthis.canThrow = true;\n\n\t\t// 将旋转的刀组成一个组\n\t\tthis.knifeGroup=this.add.group();\n\n\n\t\t// 加载刀和圆木\n\t\tthis.knife = this.add.sprite(game.config.width/2, game.config.height/5*4,\"knife\");\n\t\tthis.target = this.add.sprite(game.config.width/2,400,\"target\");\n\n \t\t// 将圆木放在第一层,即最上层\n\t\tthis.target.depth = 1;\n\n\t\t// 点击后飞出刀\n\t\tthis.input.on(\"pointerdown\", this.throwKnife, this);\n\n        //v1.2 创建循环的时"}
{"chunk": "// Preload Method\npreload(){\n\n\t\t// 加载各种资源\n\t\tthis.load.image(\"target\",\"assets/target.png\");\n\t\tthis.load.image(\"knife\",\"assets/knife.png\");\n\n\t}"}
{"chunk": "// Create Method\ncreate(){\n\t\t //v1.2 在游戏一开始设置转动的速度与一致，即默认值\n        this.currentRotationSpeed = gameOptions.rotationSpeed;\n        this.newRotationSpeed = gameOptions.rotationSpeed;\n\n\t\t// 在游戏开始时设置可以扔刀\n\t\tthis.canThrow = true;\n\n\t\t// 将旋转的刀组成一个组\n\t\tthis.knifeGroup=this.add.group();\n\n\n\t\t// 加载刀和圆木\n\t\tthis.knife = this.add.sprite(game.config.width/2, game.config.height/5*4,\"knife\");\n\t\tthis.target = this.add.sprite(game.config.width/2,400,\"target\");\n\n \t\t// 将圆木放在第一层,即最上层\n\t\tthis.target.depth = 1;\n\n\t\t// 点击后飞出刀\n\t\tthis.input.on(\"pointerdown\", this.throwKnife, this);\n\n        //v1.2 创建循环的时间事件\n        var timedEvent = this.time.addEvent({\n            delay: gameOptions.changeTime,\n            callback: this.changeSpeed,\n            callbackScope: this,\n            loop: true\n        }"}
{"chunk": "// Update Method\nupdate(){\n\tupdate(time, delta){\n\n\n\t\t//v1.2 修改 使目标转动起来\n\t\t//this.target.angle += gameOptions.rotationSpeed;\n\t\tthis.target.angle += this.currentRotationSpeed;\n\n\t\t// 获取旋转的刀成员\n\t\tvar children = this.knifeGroup.getChildren();\n\n\t\t// 对于刀的每个成员\n\t\tfor (var i=0; i<children.length; i++){\n\n\t\t\t//v1.2 修改 刀旋转的速度设置与当前速度一致\n\t\t\t//children[i].angle += gameOptions.rotationSpeed;\n\t\t\tchildren[i].angle += this.currentRotationSpeed;\n\n\t\t\t // 将角度转化为弧度\n\t\t\tvar radians = Phaser.Math.DegToRad(children[i].angle + 90);\n\n\t\t\t// 再用弧度转化为相应刀的坐标\n\t\t\tchildren[i].x = this.target.x + (this.target.width/2)*Math.cos(radians);\n            children[i].y = this.target.y + (this.target.width/2)*Math.sin(radians);\n\t\t}"}
{"chunk": "// Sprite Logic\nfunction(){\n\t// 游戏的参数设置\n\tvar gameConfig={\n\t\ttype: Phaser.CANVAS,\n\t\twidth: 750,\n\t\theight: 1334,\n\t\tbackgroundColor: 0x444444,\n\t\tscene: [playGame]\n\t};\n\tgame = new Phaser.Game(gameConfig);\n\twindow.focus();//获得窗口焦点\n\tresize();//调整窗口\n\twindow.addEventListener(\"resize\",resize,false);\n}\nclass playGame extends Phaser.Scene{\n\n\tconstructor(){\n\t\tsuper(\"playGame\");\n\t}\n\t// 预加载\n\tpreload(){\n\n\t\t// 加载各种资源\n\t\tthis.load.image(\"target\",\"assets/target.png\");\n\t\tthis.load.image(\"knife\",\"assets/knife.png\");\n\n\t}\n\t// 游戏开始运行\n\tcreate(){\n\t\t //v1.2 在游戏一开始设置转动的速度与一致，即默认值\n        this.currentRotationSpeed = gameOptions.rotationSpeed;\n        this.newRotationSpeed = gameOptions.rotationSpeed;\n\n\t\t// 在游戏开始时设置可以扔刀\n\t\tthis.canThrow = true;\n\n\t\t// 将旋转的刀组成一个组\n\t\tthis.knifeGroup=this.add.group();\n\n\n\t\t// 加载刀和圆木\n\t\tthis.kn"}
{"chunk": "// Sprite Logic\nfunction(tween){\n\n\t\t\t\t\t//v1.1 新增 合法飞出参数\n\t\t\t\t\tvar legalHit = true;\n\t\t\t\t\t//v1.1 新增 已经在圆木上刀成员\n\t\t\t\t\tvar children = this.knifeGroup.getChildren();\n\t\t\t\t\t//v1.1 对于在圆木上的每一把刀设置约束角度\n                    for (var i=0; i<children.length; i++){\n \n                        //v1.1 判断当前飞刀与圆木上的刀是否在约束范围之内\n                        if(Math.abs(Phaser.Math.Angle.ShortestBetween(this.target.angle, children[i].impactAngle)) < gameOptions.minAngle){\n \n                            //v1.1 确定标记参数\n                            legalHit = false;\n \n                            //v1.1 一旦在约束范围内就停止\n                            break;\n                        }\n                    }\n                    // 原来合法飞出\n                    if(legalHit){\n\n\t\t\t\t\t\t// 玩家现可以再次扔刀\n\t\t\t\t\t\tthis.canThrow= true;\n\n\t\t\t\t\t\t// 将飞出的刀插在圆木上\n\t\t\t\t"}
